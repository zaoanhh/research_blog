{
  "hash": "86f1f4f952c1a5a2c2dc1773a52e6c67",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 基于 Julia 的 FMCW 雷达工作原理仿真\nformat:\n  html:\n    code-fold: true\n    toc: true\n    code-tools: true\n    default-image-extension: svg\nauthor:\n  - name: Fei Shang\n    orcid: 0000-0002-5495-8869\n    email: feishang@mail.ustc.edu.cn\n    affiliations: USTC\ndate: last-modified\ncategories:\n  - code\n  - Julia\n  - radar\njupyter: julia-1.10\nexecute:\n  freeze: auto  # re-render only when source changes\n---\n\n\n本文介绍了fmcw测距的julia仿真。\n\n## FFCW 测距\n\n雷达通常也被叫做调频连续波（FMCW）雷达是一个使用频率调制来测量目标的距离的系统。在频率调制中，电磁波的频率随时间线性增加。或者说，发射频率会以恒定速率改变。这种频率随着时间线性增加的信号被称为 chirp。FMCW 系统测量发射信号和反射信号频率的瞬时差异δf，这直接和反射的 chirp 的时间差成比例。这个时间差能用来计算目标的距离。\n\n![](images/4100650ab06cc0952fe0d20e5bfc07ca7d94e3e6cc3364bde2cedb456bbc6667.png)\n\n上图（左）显示了一个 chirp 频率随时间变化的表现，右边显示频率随时间线性增加的 chirp 的幅度随时间变化图。\n\n雷达前面的单目标产生的中频信号是一个固定频率音调，这个频率由下式给出：\n\n$$\nIF = \\frac{2 \\beta d}{c}\n$$\n\n这里 $d$ 是目标到雷达的距离，单位 m，$c$ 是光速，m/s，$\\beta$ 是 chirp 斜率，由 chirp 持续时间内带宽的变化率得到。因此，我们可以对中频信号做 FFT 得到频率，再通过测量频率来计算距离。\n\n## 测距仿真\n\n1. 设置雷达参数\n\n::: {#854ecb30 .cell execution_count=1}\n``` {.julia .cell-code}\n# 导入包\nusing FFTW, SignalAnalysis\nusing CairoMakie, LinearAlgebra \nusing DSP\nCairoMakie.activate!(type=\"svg\")\nfunction myfig(;length_div_width=4/2,linewidth=28,fig_width_div_linewidth=0.5,scale=2.0)\n    cm_to_pt = 28.3464566929134\n    fig_length = floor(Int,linewidth * fig_width_div_linewidth * cm_to_pt * scale)\n    fig_width = floor(Int,fig_length / length_div_width)\n    return Figure(size =(fig_length,fig_width),pt_per_unit = 1)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nmyfig (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {#7deb8afd .cell execution_count=2}\n``` {.julia .cell-code}\n# 定义常量\nmaxR = 200.0      # 最大范围 (m)\nrangeRes = 1.0    # 范围分辨率 (m)\nmaxV = 70.0       # 最大速度 (m/s)\n# const fc = 77e9         # 载波频率 (Hz)\nfc = 0.0         # 载波频率 (Hz)\nc = 3e8           # 光速 (m/s)\n\n# 目标参数\nr0 = 100.0        # 目标距离 (m)\nv0 = 70.0         # 目标速度 (m/s)\n\n# 计算带宽和其他参数\nB = c / (2 * rangeRes)  # 带宽 (Hz)\nTchirp = 2.5 * 2 * maxR / c  # Chirp时间 (s)\nendle_time = 6.3e-6     # 结束时间 (s)\nslope = B / Tchirp      # Chirp斜率 (Hz/s)\nf_IFmax = (slope * 2 * maxR) / c  # 最大IF频率 (Hz)\nf_IF = (slope * 2 * r0) / c  # 当前IF频率 (Hz)\n\n# ADC采样点数和其他参数\nNd = 1          # Chirp数量\nNr = 1024         # ADC采样点数\nvres = (c / fc) / (2 * Nd * (Tchirp + endle_time))  # 速度分辨率 (m/s)\nFs = Nr / Tchirp        # 采样率 (samples/s)\nB\n```\n:::\n\n\n2. 发射信号, 假设发射的是 cos 信号，频率随时间线性变化，假设初始相位为0。发射信号为 $cos(2 \\pi  \\int_0^t f(t))$，其中 $f(t)$ 是随时间变化的频率, $f = f_c + \\beta t$\n\n::: {#0e9fa22a .cell execution_count=3}\n``` {.julia .cell-code}\nt = range(0, stop=Nd*Tchirp, length=Nr*Nd)  # 时间向量\ndt = t[2] - t[1]  # 时间步长\nfreq = fc .+ mod.(slope .* t,B)  # 发射信号的频率\nangle_freq = [sum(freq[1:i].*dt) for i in axes(t,1)]  # 发射信号的角度频率\n\n# 生成发射波形\nTx = cos.(2 * pi * angle_freq)  # 发射波形\n\nfig_tx = myfig(length_div_width=3,linewidth=28)\nax_tx = Axis(fig_tx[1, 1], xlabel=\"Time (s)\", ylabel=\"Amplitude\",title=\"发射信号\")\nlines!(ax_tx, t[1:Nr], Tx[1:Nr])\n\nax_freq = Axis(fig_tx[1, 2], xlabel=\"Time (s)\", ylabel=\"Frequency (GHz)\", title=\"频率随时间的变化\")\nlines!(ax_freq, t[1:Nr], freq[1:Nr]./1e9)\nfig_tx\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie C:\\Users\\SHF_1\\.julia\\packages\\Makie\\6c4lt\\src\\scenes.jl:229\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-2.svg){}\n:::\n:::\n\n\n3.接收信号, 接收波形可以从发射波形和时延计算。对于目标距离 $r_0$，信号时延为 $t_d=2r_0/c$，接收信号为 $cos(2 \\pi  \\int_0^t f(t - t_d))$。\n\n::: {#102316c9 .cell execution_count=4}\n``` {.julia .cell-code}\ntd = 2 * r0 / c  # 目标延迟时间\nfreq_rx = [t_now > td ? fc .+ mod.(slope .* (t_now.-td),B) : fc for t_now in t]   # 接收信号的频率\nangle_freq_rx = [sum(freq_rx[1:i].*dt) for i in axes(t,1)]  # 接收信号的角度频率\nRx = cos.(2 * pi .* angle_freq_rx)  # 接收信号\nfig_rx = myfig(length_div_width=3,linewidth=28)\nax_rx = Axis(fig_rx[1, 1], xlabel=\"Time (s)\", ylabel=\"Amplitude\",title=\"接收信号\")\nlines!(ax_rx, t[1:Nr], Rx[1:Nr])\n\nax_freq = Axis(fig_rx[1, 2], xlabel=\"Time (s)\", ylabel=\"Frequency (GHz)\", title=\"频率随时间的变化\")\nlines!(ax_freq, t[1:Nr].+td, freq_rx[1:Nr]./1e9)\nfig_rx\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie C:\\Users\\SHF_1\\.julia\\packages\\Makie\\6c4lt\\src\\scenes.jl:229\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](index_files/figure-html/cell-5-output-2.svg){}\n:::\n:::\n\n\n发射信号和接收信号的[时频图](https://arxiv.org/pdf/2101.06707)对比如下：\n\n::: {#fe8bedcd .cell execution_count=5}\n``` {.julia .cell-code}\n# TX_stft = tfd(Rx[1:Nr], Spectrogram(nfft=64, window=hanning,noverlap=63),fs=Fs)\nTX_stft = tfd(Tx[1:Nr], Wigner(nfft=256, smooth=10, method=:CM1980, window=hamming),fs=Fs)\nRX_stft = tfd(Rx[1:Nr], Wigner(nfft=256, smooth=10, method=:CM1980, window=hamming),fs=Fs)\nfig_stft = myfig(length_div_width=3,linewidth=28)\nax_tx_stft = Axis(fig_stft[1, 1], xlabel=\"Time (s)\", ylabel=\"Frequency (GHz)\",title=\"发射信号\")\nheatmap!(ax_tx_stft,TX_stft.time,TX_stft.freq ./1e9,TX_stft.power',colormap=:roma)\n\nax_rx_stft = Axis(fig_stft[1, 2], xlabel=\"Time (s)\", ylabel=\"Frequency (GHz)\",title=\"接收信号\")\nheatmap!(ax_rx_stft,RX_stft.time,RX_stft.freq ./ 1e9,RX_stft.power',colormap=:roma)\nfig_stft\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie C:\\Users\\SHF_1\\.julia\\packages\\Makie\\6c4lt\\src\\scenes.jl:229\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-6-output-2.svg){}\n:::\n:::\n\n\n4. 计算中频信号。中频信号是接收信号与发射信号相乘，然后低通滤波的结果，为 $\\text{IF} = cos(2\\pi \\int_0^t (f(t-t_d)-f(t)))$，注意到 **在实际的毫米波设备上，一个chirp信号发完之后会留出很长的空闲时间**，在这里我们只关注一个chirp信号的情况\n\n::: {#06338254 .cell execution_count=6}\n``` {.julia .cell-code}\nend_index = round(Int,(maximum(t)-td)/maximum(t)*Nr)\nIF_angle_freq_all = [sum((freq[1:i].-freq_rx[1:i]).*dt) for i in axes(t,1)]\nIF_angle_freq = IF_angle_freq_all[end_index+1:Nr]  # 中频信号的角度频率\n\nIFx = cos.(2 * pi .* IF_angle_freq)  # 中频信号\nfig_ifx = myfig(length_div_width=3,linewidth=28)\nax_ifx = Axis(fig_ifx[1, 1], xlabel=\"Time (s)\", ylabel=\"Amplitude\",title=\"接收信号\")\nlines!(ax_ifx, t[end_index+1:Nr], IFx)\nIFX_fft = (abs.(fft([i>length(IFx) ? 0.0 : IFx[i] for i in 1:Nr])))\nax_ifx = Axis(fig_ifx[1, 2], xlabel=\"频率 (GHz)\", ylabel=\"Amplitude\", title=\"FFT \")\nlines!(ax_ifx, IFX_fft[1:round(Int,Nr/2)]./Nr)\nfig_ifx\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie C:\\Users\\SHF_1\\.julia\\packages\\Makie\\6c4lt\\src\\scenes.jl:229\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](index_files/figure-html/cell-7-output-2.svg){}\n:::\n:::\n\n\n::: {#d3a8f27a .cell execution_count=7}\n``` {.julia .cell-code}\nfreq_res = findfirst(x->x==maximum(IFX_fft[1:round(Int,Nr/2)]),IFX_fft[1:round(Int,Nr/2)])\nres = (freq_res / Nr ) * Tchirp *c\nprintln(\"目标距离为: \",res,\" m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n目标距离为: 98.6328125 m\n```\n:::\n:::\n\n\n## 多天线测角度\n\n::: {#aac6d75b .cell execution_count=8}\n``` {.julia .cell-code}\nxx = zeros(ComplexF64, 181)\nθ = π /3\nnum = 30\nxx[1:num] .= exp.((1:num) .* 1im .* sin(θ) .* π )\nfig_test = myfig(length_div_width=3,linewidth=28)\nax_test = Axis(fig_test[1, 1], xlabel=\"Real\", ylabel=\"Imaginary\",title=\"复数\")\nlines!(ax_test, collect(-90:90),abs.(fftshift(fft(xx))))\nfig_test\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie C:\\Users\\SHF_1\\.julia\\packages\\Makie\\6c4lt\\src\\scenes.jl:229\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](index_files/figure-html/cell-9-output-2.svg){}\n:::\n:::\n\n\n::: {#62078b93 .cell execution_count=9}\n``` {.julia .cell-code}\nres_aoa=asin((findfirst(abs.(fftshift(fft(xx))) .== maximum(abs.(fftshift(fft(xx)))))-90)/90) / π *180\nprintln(\"目标角度为: \",res_aoa,\" °\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n目标角度为: 61.375449046574644 °\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}